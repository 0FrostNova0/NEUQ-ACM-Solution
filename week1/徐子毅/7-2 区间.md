# 7-2 区间

> 有一个长为n的序列，一个区间的权值定义为这个区间内不同数字的个数，请在这个序列中找出两段不相交的区间使它们的权值的和最大

+ 可以注意到区间越长，权值只增不减，所以应该考虑最长的区间，即两个区间的长度就是原区间的长度。

本题我本来用插板，这应该是正确的思路，但是在找前后区间权值时我用了暴力搜索导致时间耗费太长，所以应该考虑细微一点。插板移动时，有一个数分配给了前面的区间，同时后面的区间少了一个数。每一次移动应该只考虑增减而不是全盘考虑。

*我的代码中，tap即插板。插板的位置为正数第tap个数的后面，这样的话，每次变化的数就是a[tap]。*

+ 同时我利用两个计数器memofront和memoback。
  + memofront为前段区间的计数器，实际上应该是判断器，这个memofront的值只有0或1，是因为这个是代表这个数有没有存在过。
  + memoback为后段区间的计数器，由于后段区间的特殊性，memoback的意义是这个数出现的次数。只有当memoback[nu]==1时，即减去的这个数为后半区间出现的唯一的数，才能把后面的权值减去1。

```C++
#include <iostream>
using namespace std;
int main(){
	int N;
	cin >> N;
	int memofront[100005],memoback[100005];
	int a[N];
	for(int i=0;i<N;i++) cin >> a[i];
	int tap=1,maxweight=0;
	if(N==2) {cout << 2 << endl; return 0;}
	for(int i=0;i<100005;i++) {memofront[i]=0;memoback[i]=0;}
	int frontweight=0,backweight=0;
	//第一次扫描，此时tap=1，
    //本人没事找事，下面两个for根本无意义，i就是0
	for(int i=0;i<tap;i++){
		if(memofront[a[i]]==1) continue;
		else {
			memofront[a[i]]=1;
		        frontweight++;
		}
	}
	for(int i=tap;i<N;i++){
		if(memoback[a[i]]>0) {memoback[a[i]]++;continue;}
		else {
			memoback[a[i]]=1;
		        backweight++;
		}
	}
	int weight=frontweight+backweight;
	//开始移动插板
	for(tap=1;tap<N-1;tap++){
		if(memofront[a[tap]]==0) {frontweight++;memofront[a[tap]]++;}//如果加进来的数在前段没有出现过，就增加前段的权值，并将这个数标记。
		if(backweight>0){//防止减到负数，应该不会出现这种情况。
			if(memoback[a[tap]]>1) memoback[a[tap]]--;//减去出现次数。
			else if (memoback[a[tap]]==1) {//只有当memoback为1时才能减权值。
				memoback[a[tap]]=0;backweight--;
			}
		}
		int weight=frontweight+backweight;
		if(weight>maxweight) maxweight=weight;
	}
	cout << maxweight << endl;
	return 0;
}
```

