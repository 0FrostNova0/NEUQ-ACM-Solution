# Week1题解

## 7-1

### 题目

#### 题目

> 给定一个只含有小写字母的文本串，给定*n*个模式串，求每个模式串在文本串中的出现次数。

#### 输入格式

> 第一行输出模式串的个数*n*
>
> 接着从第二行开始读入一个文本串，文本串只包含小写字母，无空格和回车
>
> 再之后读入*n*行模式串，模式串之间用回车间隔
>
> 需要注意的是：
>
> *n*≤20
>
> 文本串的长度 ≤50000
>
> 模式串的长度≤20

#### 输出格式

> 输出共包括*n*行，每一行按顺序输出每一个模式串的出现次数.

#### 输入样例

```
3
abcabcabcabbb
abc
ab
b
```

#### 输出样例

```
3
4
6
```

### 题解

#### 题意

> 给定一个字符串和若干模式串，匹配字符串中有多少个该模式串，输出个数。

#### 思考

> 读入字符串 s，记 i 表示字符串的第 i + 1 位，从 i = 0 循环到 i = s.length() - 1，读入 模式串 x，记 j 为模式串第 j + 1 位。
>
> 定义 is 变量，初始值为1，表示模式串匹配成功，定义 times 变量 初始值为 0 表示模式串匹配次数，对 i 循环内再从 j = 0 循环到 j = x.length() - 1。如果 s[i + j] != x[j] 则把 is 赋值为 0，表示字符串从第 i + 1 位开始与模式串同长度的字符串不与模式串匹配。循环结束，如果 is = 1 则 times++

#### 鄙陋代码

```c++
#include <iostream>

using namespace std;

int main() {
    // 模式串个数 n
    int n;
    cin >> n;
    // 字符串 s
    string s;
    cin >> s;
    // 结果数组
    int res[n];
    for (int i = 0; i < n; i++) {
        // 模式串 chs
        string chs;
        cin >> chs;
        // 该模式串 chs 在字符串 s 中匹配次数 total 默认为 0
        int total = 0;
        for (int j = 0; j < s.length(); j++) {
            // 模式串是否与字符串片段匹配 默认为是(1)
            int is = 1;
            // 如果模式串与字符串片段有字符不匹配则把 is 赋值为 0
            for (int k = 0; k < chs.length(); k++) {
                if (s[j+k] != chs[k]) {
                    is = 0;
                }
            }
            // 若 is 为 1，即模式串与字符串匹配 匹配次数 total 加一
            if (is == 1) {
                total++;
            }
        }
        // 匹配次数 赋值给结果数组
        res[i] = total;
    }
    // 输出结果
    for (int i = 0; i < n; i++) {
        i != n - 1 ? cout << res[i] << endl : cout << res[i];
    }
    return 0;
}
```



## 7-2

### 题目

#### 题目

> 有一个长为n的序列，一个区间的权值定义为这个区间内不同数字的个数，请在这个序列中找出两段不相交的区间使它们的权值的和最大.

#### 输入格式

> 第一行读入数据组数*n*
>
> 第二行*n*个数(*n*<1*e*6,*ai<1*e*5)

#### 输出格式

> 输出一个整数表示最大的权值

#### 输入样例

```
5
1 2 3 2 1
```

#### 输出样例

```
5
```

### 题解

#### 题意

> 找出数组数列中间一个分界点，使得之前的数（包含分界点）中不同数字的个数（权）与之后的数（不包含分界点）中不同数字的个数（权）之和最大。

#### 思考

> 读入数组字符串时取出最大的数字 max_num，以此为数组长度开两个数组 tmp[max_num]，tmp2[max_num]，作为开的桶记录数字是否出现过。
>
> 从 i = 0 循环到 i = n - 1，如果 tmp[q[i]] != 1则权 + 1，并把他赋值为1，这样就可以记录从左到右，循环到该位时权值。
>
> 然后从 i = n - 1 循环到 i = 0，如果 tmp2[q[i]] != 1则权 + 1，并把他赋值成1，这样就可以记录从右到左，循环到该位时权值。
>
> 分别存到数组中，分别相加并取出最大的和值。即为最大权值。
>
> **相加时要错一位**

#### 鄙陋代码

```c++
#include <iostream>

using namespace std;

const int N = 1e8 + 100;
int q[N];

int main()
{
    int n;
    cin >> n;
    // 读入的最大数字
    int max_num = 0;
    for (int i = 0; i < n; i++) {
        cin >> q[i];
        if (max_num <= q[i]) {
            max_num = q[i];
        }
    }
    // 正向和逆向权值
    int a = 0,b = 0;
    // 正逆向权值数组
    int a1[n],b1[n];
    // 桶
    int tmp[max_num],tmp2[max_num];
    // 正向循环
    for (int i = 0; i < n; i++) {
        if (tmp[q[i]] != 1) {
            tmp[q[i]] = 1;
            a++;
        }
        a1[i] = a;
    }
    // 逆向循环
    for (int i = n - 1; i >= 0; i--) {
        // 这里赋值 b 还是 b - 1 的区别就是为了错一位相加
        if (tmp2[q[i]] != 1) {
            tmp2[q[i]] = 1;
            b++;
            b1[i] = b - 1;
        } else {
            b1[i] = b;
        }
    }
    // 两侧权值和最大值
    int max = a1[0] + b1[0];
    for (int i = 0; i < n; i++) {
        if (max <= (a1[i] + b1[i])) {
            max = a1[i] + b1[i];
        }
    }
    cout << max;
    return 0;
}
```

## 7-3

### 题目

#### 题目

> 众所周知，校园跑使用小步点软件时需要依次经过5个点位，一天Phenix发明了一个范围增强器，当Phenix距离点位R米的时就算经过了该点位，现在Phenix公里数已经达到了2公里，但是还剩两个点位需要经过，现在将校园抽象为一个二维坐标系，假设Phenix在（0,0）点，剩下的第一个点位在（d,n）,第二个在(2d,0)，由于Phenix超过了两公里的部分是一点也不想多跑，所以你需要计算在拥有范围增强器的基础上依次经过这两个点位的最短距离。

#### 输入格式

> 三个整数R，d，n。（R>0,|d|，|n|，|R|<=1000）
>
> 保证4 * R * R <= d * d + n * n

#### 输出格式

> 一个两位小数，表示最短距离

#### 输入样例

```
1 3 5
```

#### 输出样例

```
9.00
```

### 题解

#### 题意

> 从以(d,n)为圆心的圆上取一点该点到原点距离与该点到以(2d,0)为圆心的圆上距离之和最小。

#### 思考

> 当以(d,n)为圆心的圆不过坐标 x 轴时，该点应为 (d,n - R) 最短距离为 2 * sqrt(pow(d,2) + pow(n - R,2)) - R。
>
> 当过坐标轴 x 轴时，距离为 2d - R。

#### 鄙陋代码

```c++
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    int R,d,n;
    cin >> R >> d >> n;
    if (d < 0) {
        d = -1 * d;
    }
    if (n < 0) {
        n = -1 * n;
    }
    double res;
    if (R > n) {
        res = 2.0 * d - R;
        printf("%.2f",res);
    } else {
        res = 2.0 * sqrt(pow(n - R,2) + pow(d,2)) - R;
        printf("%.2f",res);
    }
    return 0;
}
```

## 7-4

### 题目

#### 题目

> 现在有n个糖果和一群小朋友，第一个小朋友拥有这n个糖果，他现在有两种选择①分给第二个小朋友x个，x必须是n的约数，且x<n②全部自己留着，第二个小朋友同样也是要么分自己拥有糖果数的约数个给下一个小朋友，要么全留着，以此类推。现在给出第一个小朋友的糖果数n，询问有多少种分法。

#### 输入格式

> 输入一个整数（n <= 1000）

#### 输出格式

> 方案数

#### 输入样例

```
6
```

#### 输出样例

```
6
```

### 题解

#### 题意

> 定义一个 total 变量，初始值为 1 ，给出一个 n ，求出他的因子个数加到 total 上，再递归求他的因子的因子个数。

#### 思考

> 递归，函数接受一个参数 n ，如果有因子则把因子赋值给 n ，递归下去。return total

#### 鄙陋代码

```c++
#include <iostream>

using namespace std;

int res = 1;

int func(int n) {
    for (int i = 1; i < n; i++) {
        if (n % i == 0) {
            res++;
            func(i);
        }
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    func(n);
    cout << res;
    return 0;
}
```

## 7-5

### 题目

#### 题目

> 一天Phenix的眼镜被俱乐部某个成员拿了，然后所有的俱乐部成员围成了一个圈，每个人都有个编号，按逆时针递增，而且每个人都有朝向（面向圈内或者圈外），Phenix需要询问编号为1的同学是谁拿的眼镜，但是俱乐部成员很团结不会出卖队友，只会告诉他，例如“眼镜藏在我左数第3个人的右数第1个人的左数第2个人那里”这种形式。现在给出每个人的朝向和名字，和1号同学给出的提示，你需要帮他找出是谁拿的眼镜。

#### 输入格式

> 第一行两个整数n，m表示有n个人，m个提示，接下来n行，每行一个数字0/1和一个字符串，按1到n的编号顺序依次给出每个人的朝向（0朝向圈内，1朝向圈外）和名字。 再接下来m行，每行同样两个数字0/1,x。表示眼镜往左/右数x个人那里
>
> (n,m<=100000)

#### 输出格式

> 输出拿了眼镜的同学的名字

#### 输入样例

```
7 3
0 ymh
0 lc
0 zx 
1 wjq
1 ld
0 hhj
1 yh 
0 3
1 1
0 2
```

#### 输出样例

```
hhj
```

### 题解

#### 题意

> 根据 m 个提示计算出总的相对于第一个学生眼镜所在同学的位置。

#### 思考

> 通过画图或者想象发现，如果提示中方位（左或者右）与学生朝向相同则为减，否则为加。以此计算出最终持有眼镜的同学的索引。输出该同学的名字即可。

#### 鄙陋代码

```c++
#include <iostream>

using namespace std;

struct stu {
    int to;
    string name;
};

int main() {
    int n, m;
    cin >> n >> m;
    stu stus[n];
    for (int i = 0; i < n; i++) {
        cin >> stus[i].to >> stus[i].name;
    }
    // a b 分别是左或者右 以及移动的位数 index 即为最终眼镜所在同学的索引
    int a, b,index = 0;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        if (a == stus[index].to) {
            index -= b;
        } else {
            index += b;
        }
        if (index < 0) {
            index = n + index;
        }
        if (index > n - 1) {
            index = index - n;
        }   
    }
    cout << stus[index].name;
    return 0;
}
```

## 7-6

### 题目

#### 题目

> Phenix今天又有早八，由于他喜欢卡点到，所以只给自己留了T分钟的时间吃饭。鹏远餐厅有n道菜，每道菜有一个快乐值v和用餐时间t，意为Phenix可以花t分钟吃掉这道菜，然后获得v的快乐值。但是如果吃早饭的时间太长了，导致他迟到了他也会感到不开心，具体的，如果t > T,他获得的快乐值就是v-(t-T)。现在请你计算Phenix吃掉某一道菜能获得的最大快乐值。

#### 输入格式

> 第一行两个整数n,T,接下来n行每行两个数表示每道菜的快乐值和用餐时间。n<=100000。

#### 输出格式

> 输出Phenix能获得的最大快乐值（注意可能是负数）

#### 输入样例

```
2 5
3 3
4 5
```

#### 输出样例

```
4
```

### 题解

#### 题意

> 给定一个最大时间 T ，若吃饭用时超过 T 则快乐值为 v = v - (t - T) 否则为 v = v(输入的 v 值)
>
> 找出 n 个 菜最大的 v

#### 思考

> 无

#### 鄙陋代码

```c++
#include <iostream>

using namespace std;

int main() {
    int n,T;
    cin >> n >> T;
    int nums[n][2];
    for (int i = 0; i < n; i++) {
        cin >> nums[i][0] >> nums[i][1];
    }
    int res[n];
    for (int i = 0; i < n; i++) {
        int t = nums[i][1];
        int v = nums[i][0];
        if (t > T) {
            res[i] = v - (t - T);
        } else {
            res[i] = v;
        }
    }
    int max = res[0];
    for (int i = 0; i < n; i++) {
        if (res[i] >= max) {
            max = res[i];
        }
    }
    cout << max;
    return 0;
}
```
